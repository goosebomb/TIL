/*
	* 자료구조(Data Struct)
	자료들의 집합을 의미
	각 원소들이 논리적으로 정의된 규칙에 의해 나열
	나열된 자료에 대한 처리를 효율적으로 수행할 수 있도록 자료를 구분하여 표현한 것
	자료를 효율적으로 저장하고 관리하면 실행시간을 단축 또는 메모리 절약

	* 선형자료구조
	자료들이 순서대로 나열되는 구조
	배열, 스택, 큐, 연결리스트, 덱

	* 비선형자료구조
	복잡한 연결을 갖는 형태
	트리, 그래프

	* 알고리즘
	알고리즘은 저장된 데이터를 이용하여 문제를 해결하기 위한 절차나 방법을 의미
	좋은 알고리즘을 만들기 위해서는 5가지 조건이 있다.
	입력   : 0개 이상의 입력이 존재해야 한다.
	출력   : 1개 이상의 출력이 존재해야 한다.
	명확성 : 각 명령어의 의미는 모호하지 않고 명확해야 한다.
	유한성 : 한정된 수의 단계 후에는 반드시 종료해야 한다.
	유효성 : 각 명령어들은 실행 가능한 연산이어야 한다.

	* 시간복잡도
	알고리즘의 수행시간을 분석한 결과를 시간복잡도라고 한다

	* 공간복잡도
	메모리 사용량을 분석한 결과를 공간복잡도라고 한다.

	* 빅오표기법 (Big - O)
	알고리즘의 효율을 측정하는 방법

	<알고리즘의 효율을 측정하려면?>
	두 알고리즘 A와 B를 비교한다.
	1. A가 B보다 "조금", "많이" 빠르다 -> 애매모호
	2. 프로그램을 짜서 실행속도를 비교 -> 환경에 의존적
	3. 입력에 적은구간에 많은구간에서 성능이 확연하게 차이날 경우 빅오 표기법 사용
*/

//* Big - O 표기법 1단계
//수행되는 연산(산술, 비교 대입 등)의 갯수를 "대략적으로" 판단

// 1) 더하기가 1개 있어서 "1"이다
int Add1(int n)
{
	return n + n;
}

// 2) n번 반복하고 더하기가 1개 있으므로 "N + 1"이다
int Add2(int n)
{
	int sum = 0;
	for (int i = 0; i < n; i++)
	{
		sum += i;
	}
	return sum;
}

// 3) n * n번 반복하고 더하기가 1개 있으므로 "N^2 + 1"로 표기
int Add3(int n)
{
	int sum = 0;
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
		{
			sum += i;
		}
	}
	return sum;
}

// *빅오표기법 2단계
// 영향력이 가장 큰 대표항목만 남기고 삭제, 상수는 무시한다.

// 1 + N + 1 + N^2 + 1 + 1 = N^2 + N + 4 -> N^2
// 가장 영향력이 큰 N^2이 된다.
int Add4(int n)
{
	int sum = 0;
	for (int i = 0; i < n; i++)
	{
		sum += i;
	}

	for (int i = 0; i < 2 * n; i++)
	{
		for (int j = 0; j < 2 * n; j++)
		{
			sum += i;
		}
	}
	sum += 1234567;
	return sum;
}